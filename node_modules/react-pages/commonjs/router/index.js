"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Redirect", {
  enumerable: true,
  get: function get() {
    return _found.Redirect;
  }
});
Object.defineProperty(exports, "RedirectException", {
  enumerable: true,
  get: function get() {
    return _found.RedirectException;
  }
});
exports.createRouterStoreEnhancers = createRouterStoreEnhancers;
Object.defineProperty(exports, "foundReducer", {
  enumerable: true,
  get: function get() {
    return _found.foundReducer;
  }
});
exports.getMatch = getMatch;
exports.getMatchThatHasBeenLoaded = getMatchThatHasBeenLoaded;
exports.getMatchedLocation = getMatchedLocation;
exports.getMatchedLocationThatHasBeenLoaded = getMatchedLocationThatHasBeenLoaded;
exports.getMatchedRoutes = getMatchedRoutes;
exports.getMatchedRoutesIndices = getMatchedRoutesIndices;
exports.getMatchedRoutesParams = getMatchedRoutesParams;
exports.getRouteParams = getRouteParams;
exports.getRoutePath = getRoutePath;
exports.getRoutesByPath = getRoutesByPath;
exports.matchRoutes = matchRoutes;
Object.defineProperty(exports, "useRouter", {
  enumerable: true,
  get: function get() {
    return _found.useRouter;
  }
});
var _found = require("@catamphetamine/found");
var _farce = require("@catamphetamine/farce");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function createRouterStoreEnhancers(routes, createHistoryProtocol) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var middlewares = [
  // Parses `location.search` string into `location.query` object.
  _farce.queryMiddleware];
  if (options.basename) {
    middlewares.push((0, _farce.createBasenameMiddleware)({
      basename: options.basename
    }));
  }
  return [(0, _farce.createHistoryEnhancer)({
    protocol: createHistoryProtocol(),
    middlewares: middlewares
  }), (0, _found.createMatchEnhancer)(
  // new Matcher(hotRouteConfig(routes))
  new _found.Matcher(routes))];
}
function matchRoutes(store) {
  return (0, _found.getStoreRenderArgs)({
    store: store,
    resolver: _found.resolver,
    matchContext: {
      dispatch: store.dispatch,
      getState: store.getState
    }
  }).then(function (renderArgs) {
    if (renderArgs.error) {
      throw renderArgs.error;
    }
    return renderArgs;
  });
}
function getRoutesByPath(routeIndices, routes) {
  var matchedRoutes = [];
  var _iterator = _createForOfIteratorHelper(routeIndices),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var i = _step.value;
      matchedRoutes.push(routes[i]);
      routes = routes[i].children;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return matchedRoutes;
}
function getMatch(state) {
  return state.found.match;
}
function getMatchedRoutes(state, routes) {
  return getRoutesByPath(getMatch(state).routeIndices, routes);
}
function getMatchedRoutesIndices(state) {
  return getMatch(state).routeIndices;
}

// A URL can consist of several "routes": a parent route + possible sub-routes.
// "Matched route params" are just this particular route's params for a given URL.
// All routes' params are the combined params for all matched routes for a given URL.
//
// Example:
//
// const routes = [{
//   path: ':foo',
//   children: [{
//     path: ':bar'
//   }]
// }]
//
// const location = {
//   pathname: '/a/b'
// }
//
// const routeParams = [
// 	{ foo: 'a' },
// 	{ bar: 'b' }
// ]
//
// const params = {
//   foo: 'a',
//   bar: 'b'
// }
//
function getMatchedRoutesParams(state) {
  return getMatch(state).routeParams;
}
function getRouteParams(state) {
  return getMatch(state).params;
}
function getMatchedLocation(state) {
  return getMatch(state).location;
}
function getMatchThatHasBeenLoaded(state) {
  return state.found.resolvedMatch;
}
function getMatchedLocationThatHasBeenLoaded(state) {
  return getMatchThatHasBeenLoaded(state) && getMatchThatHasBeenLoaded(state).location;
}

// Returns a complete route path for matched routes chain.
// E.g. returns "/user/:user_id/post/:post_id"
// for matched URL "/user/1/post/123?key=value".
function getRoutePath(routes) {
  return routes
  // Select routes having `path` React property set.
  .filter(function (route) {
    return route.path;
  })
  // Trim leading and trailing slashes (`/`)
  // from each route `path` React property.
  .map(function (route) {
    return route.path.replace(/^\//, '').replace(/\/$/, '');
  })
  // Join route `path`s with slashes (`/`).
  .join('/') || '/';
}
//# sourceMappingURL=index.js.map