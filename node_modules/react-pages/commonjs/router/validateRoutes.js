"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = validateRoutes;
var _getRoutePath = _interopRequireDefault(require("./getRoutePath.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function validateRoutes(routes) {
  if (routes.length !== 1) {
    throw new Error('[react-pages] `routes` must be an array with one element');
  }
  if (!(routes[0].Component || routes[0].getComponent)) {
    throw new Error('[react-pages] Root route must have a `Component` or a `getComponent`');
  }

  // If `routes` is an array then it means that the routes configuration
  // is a JSON one rather than a React Element one.
  // In older versions of `react-router` they used to configure routes
  // not as JSON objects but as React Elements (weird).
  if (!Array.isArray(routes)) {
    throw new Error('[react-pages] `routes` must be a JSON structure');
  }

  // The `if` block below validated that there's no `getData` function
  // already associated to the top-level route in the chain.
  // That `if` block was eventually commented out. The reason is that
  // if there's an error on client side in `setUpAndRender()`
  // then `setUpAndRender()` gets called again in order to render the error page.
  // And in that case `getData` will already be set on `routes[0]`
  // and the `if` condition would be valid resulting in throwing the error.
  // So throwing the error was commented out.
  // if (routes[0].getData) {
  // 	throw new Error('[react-pages] `getData` found on the root route')
  // }

  // Validate that `.load()` or `.meta()` functions could only be defined
  // at "root" or "leaf" route `Component`s (page components).
  validateThatMetaOrLoadAreOnlyAtLeafRoutes(routes);
}
function validateThatMetaOrLoadAreOnlyAtLeafRoutes(routes) {
  var parentRoutes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var _iterator = _createForOfIteratorHelper(routes),
    _step;
  try {
    var _loop = function _loop() {
      var route = _step.value;
      if (route.children) {
        // This is a non-"leaf" route.

        // If it's a non-root route.
        if (parentRoutes.length > 0) {
          var validateHasNoProperty = function validateHasNoProperty(propertyName) {
            var throwError = function throwError(type) {
              throw new Error("[react-pages] Only root or leaf route".concat(type === 'component' ? ' Component' : '', "s could have a `").concat(propertyName, "` parameter. A non-leaf route").concat(type === 'component' ? ' Component' : '', " was found having a `").concat(propertyName, "` parameter for route \"").concat((0, _getRoutePath["default"])(parentRoutes.concat(route)), "\""));
            };
            if (route.Component) {
              if (route.Component[propertyName]) {
                throwError('component');
              }
            } else if (route.getComponent) {
              if (route[propertyName]) {
                throwError('route');
              }
            }
          };
          validateHasNoProperty('load');
          validateHasNoProperty('meta');
        }

        // Recurse into child routes.
        validateThatMetaOrLoadAreOnlyAtLeafRoutes(route.children, parentRoutes.concat([route]));
      } else {
        // This is a "leaf" route.
        if (!(route.Component || route.getComponent)) {
          throw new Error("[react-pages] Route \"".concat((0, _getRoutePath["default"])(parentRoutes.concat(route)), "\" must have a `Component` or a `getComponent`"));
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
//# sourceMappingURL=validateRoutes.js.map