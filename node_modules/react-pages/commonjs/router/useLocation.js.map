{"version":3,"file":"useLocation.js","names":["useLocation","useContext","RouterContext","value","location"],"sources":["../../lib/router/useLocation.js"],"sourcesContent":["import { useContext } from 'react'\r\n\r\nimport RouterContext from './RouterContext.js'\r\n\r\n// This hook doesn't simply return `state.found.resolvedMatch.location`.\r\n// The reason is that `resolvedMatch` gets updated right after a route\r\n// has been matched against the URL (and `load`ed), but there's a small gap in time\r\n// between \"the route has been matched and loaded\" and \"the router has rendered the new page\".\r\n// In other words, when the \"current location\" gets updated in router state,\r\n// the previous page is still rendered because React will re-render the whole tree\r\n// \"asynchronously\" some (indeterminate) time after the state has been updated.\r\n// This resulted in the previously rendered page getting an incorrect `location`\r\n// for a brief period of time — the location of the next page — which caused bugs.\r\n//\r\n// To work around that, this `useLocation()` hook has been created which always returns\r\n// the \"currently rendered location\" rather than just \"current location\" as per router state.\r\n//\r\n// Somewhere up the tree, `<RouterContext.Provider/>` React element is rendered,\r\n// and the context `value` that is \"provided\" by it gets updated exactly at the time\r\n// when a new page gets rendered (i.e. inside the render function), meaning that\r\n// at any given time the context `value` is accessed during a React render,\r\n// it corresponds exactly to the `location` of the page that is currently rendered on screen.\r\n//\r\nexport default function useLocation() {\r\n\treturn useContext(RouterContext).value.location\r\n}"],"mappings":";;;;;;AAAA;AAEA;AAA8C;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,WAAW,GAAG;EACrC,OAAO,IAAAC,iBAAU,EAACC,yBAAa,CAAC,CAACC,KAAK,CAACC,QAAQ;AAChD"}