"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = Router;
var _react = _interopRequireDefault(require("react"));
var _found = require("@catamphetamine/found");
var _ScrollManager = _interopRequireDefault(require("./found-scroll/ScrollManager.js"));
var _RouterContextValueProvider = _interopRequireDefault(require("../RouterContextValueProvider.js"));
var _LeafRouteContext = _interopRequireDefault(require("../LeafRouteContext.js"));
var _NonRootRouteContext = _interopRequireDefault(require("../NonRootRouteContext.js"));
var _renderRouterElementContent = _interopRequireDefault(require("../renderRouterElementContent.js"));
var _isSamePage = require("../../isSamePage.js");
var _excluded = ["dispatch", "getState"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function Router(_ref) {
  var dispatch = _ref.dispatch,
    getState = _ref.getState,
    renderArgs = _objectWithoutProperties(_ref, _excluded);
  return _react["default"].createElement(ConnectedRouter, {
    matchContext: {
      dispatch: dispatch,
      getState: getState
    },
    resolver: _found.resolver,
    initialRenderArgs: renderArgs
  });
}
var ConnectedRouter = (0, _found.createConnectedRouter)({
  render: function render(renderArgs) {
    var elements = renderArgs.elements,
      routes = renderArgs.routes;

    // Force re-mount the last route component on location path change.
    // https://github.com/4Catalyzer/found/issues/199#issuecomment-415616836
    if (elements && window.reactPagesRemountOnNavigate !== false) {
      elements[elements.length - 1] = _react["default"].cloneElement(elements[elements.length - 1], {
        key: (0, _isSamePage.getPageKey)(renderArgs.location)
      });
    }

    // The route structure could specify a "root" route and all other routes that branch out from it,
    // ending with a "leaf" route that represents the page component.
    // * A "root" route can use `usePageStateSelectorOutsideOfPage()` hook.
    // * A "leaf" route should use `usePageStateSelector()` hook instead.
    // * A non-"root" and non-"leaf" route shouldn't really use either one.
    if (elements) {
      // Mark the "leaf" route as such.
      var leafRouteElement = elements[elements.length - 1];
      elements[elements.length - 1] = _react["default"].createElement(_LeafRouteContext["default"].Provider, {
        value: true
      }, leafRouteElement);
      // Mark any routes inside the "root" route as "non-root" ones.
      var firstNonRootRouteElementIndex = renderArgs.routes[0]._isRootRoute_ ? 1 : 0;
      var firstNonRootRouteElement = elements[firstNonRootRouteElementIndex];
      elements[firstNonRootRouteElementIndex] = _react["default"].createElement(_NonRootRouteContext["default"].Provider, {
        value: true
      }, firstNonRootRouteElement);
    }

    // When a user navigates to a page, this `render()` function is called:
    // * If there's any `load()` data loader:
    //   * The first call is gonna be with `elements: undefined` and the new `location`,
    //     before the page starts loading the initial data.
    //     `<RouterContextValueProvider/>` ignores this `render()` call.
    //   * The second call is gonna be with `elements: React.Element[]` and the new `location`,
    //     after the page has loaded the initial data.
    // * Otherwise, if there's no data to load:
    //   * The page just renders with `elements: React.Element[]` and the new `location`.
    return _react["default"].createElement(_RouterContextValueProvider["default"], {
      // `elements` is `undefined` when router starts loading the next page.
      // In that case, the previous page is still rendered, so it shouldn't
      // pass the new `location` to `<RouterContextValueProvider/>` yet.
      location: elements && renderArgs.location,
      params: elements && renderArgs.params,
      routes: elements && renderArgs.routes
    }, _react["default"].createElement(_ScrollManager["default"], {
      renderArgs: renderArgs
    }, (0, _renderRouterElementContent["default"])(renderArgs)));
  }
});
//# sourceMappingURL=Router.js.map