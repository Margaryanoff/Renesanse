{"version":3,"file":"index.js","names":["MAX_SCROLL_ATTEMPTS","ScrollBehavior","addNavigationListener","stateStorage","getCurrentLocation","shouldUpdateScroll","_oldScrollRestoration","window","history","isMobileSafari","scrollRestoration","e","_ignoreScrollEvents","_saveWindowPositionHandle","animationFrame","request","_saveWindowPosition","_windowScrollTarget","xTarget","yTarget","x","scrollLeft","y","scrollTop","_cancelCheckWindowScroll","_savePosition","_checkWindowScrollHandle","Promise","resolve","scrollToTarget","_numWindowScrollAttempts","_checkWindowScrollPosition","_stateStorage","_getCurrentLocation","_shouldUpdateScroll","_setScrollRestoration","_scrollElements","addEventListener","_onWindowScroll","handleNavigation","saveWindowPosition","cancel","Object","keys","forEach","key","scrollElement","savePositionHandle","_saveElementPosition","_removeNavigationListener","action","_pageLifecycleListener","newState","_restoreScrollRestoration","PageLifecycle","element","context","invariant","saveElementPosition","onScroll","_updateElementScroll","removeEventListener","prevContext","_updateWindowScroll","then","save","_getScrollTarget","scrollTarget","location","hash","charAt","slice","call","Array","isArray","_getSavedScrollTarget","_getDefaultScrollTarget","read","target","targetElement","document","getElementById","getElementsByName","scrollIntoView","left","top"],"sources":["../../../../lib/router/client/scroll-behavior/index.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\r\n\r\nimport * as animationFrame from 'dom-helpers/cjs/animationFrame.js';\r\nimport scrollLeft from 'dom-helpers/cjs/scrollLeft.js';\r\nimport scrollTop from 'dom-helpers/cjs/scrollTop.js';\r\nimport invariant from 'invariant';\r\nimport PageLifecycle from 'page-lifecycle/dist/lifecycle.es5.js';\r\n\r\nimport { isMobileSafari } from './utils.js';\r\n\r\n// Try at most this many times to scroll, to avoid getting stuck.\r\nconst MAX_SCROLL_ATTEMPTS = 2;\r\n\r\nexport default class ScrollBehavior {\r\n  constructor({\r\n    addNavigationListener,\r\n    stateStorage,\r\n    getCurrentLocation,\r\n    shouldUpdateScroll,\r\n  }) {\r\n    this._stateStorage = stateStorage;\r\n    this._getCurrentLocation = getCurrentLocation;\r\n    this._shouldUpdateScroll = shouldUpdateScroll;\r\n    this._oldScrollRestoration = null;\r\n\r\n    // This helps avoid some jankiness in fighting against the browser's\r\n    //  default scroll behavior on `POP` navigations.\r\n    /* istanbul ignore else: Travis browsers all support this */\r\n    this._setScrollRestoration();\r\n\r\n    this._saveWindowPositionHandle = null;\r\n    this._checkWindowScrollHandle = null;\r\n    this._windowScrollTarget = null;\r\n    this._numWindowScrollAttempts = 0;\r\n    this._ignoreScrollEvents = false;\r\n\r\n    this._scrollElements = {};\r\n\r\n    // We have to listen to each window scroll update rather than to just\r\n    //  location updates, because some browsers will update scroll position\r\n    //  before emitting the location change.\r\n    window.addEventListener('scroll', this._onWindowScroll);\r\n\r\n    const handleNavigation = (saveWindowPosition) => {\r\n      animationFrame.cancel(this._saveWindowPositionHandle);\r\n      this._saveWindowPositionHandle = null;\r\n\r\n      if (saveWindowPosition && !this._ignoreScrollEvents) {\r\n        this._saveWindowPosition();\r\n      }\r\n\r\n      Object.keys(this._scrollElements).forEach((key) => {\r\n        const scrollElement = this._scrollElements[key];\r\n        animationFrame.cancel(scrollElement.savePositionHandle);\r\n        scrollElement.savePositionHandle = null;\r\n\r\n        // It's always fine to save element scroll positions here; the browser\r\n        //  won't modify them.\r\n        if (!this._ignoreScrollEvents) {\r\n          this._saveElementPosition(key);\r\n        }\r\n      });\r\n    };\r\n\r\n    this._removeNavigationListener = addNavigationListener(({ action }) => {\r\n      // Don't save window position on POP, as the browser may have already\r\n      //  updated it.\r\n      handleNavigation(action !== 'POP');\r\n    });\r\n\r\n    this._pageLifecycleListener = ({ newState }) => {\r\n      if (\r\n        newState === 'terminated' ||\r\n        newState === 'frozen' ||\r\n        newState === 'discarded'\r\n      ) {\r\n        handleNavigation(true);\r\n\r\n        // Scroll restoration persists across page reloads. We want to reset\r\n        //  this to the original value, so that we can let the browser handle\r\n        //  restoring the initial scroll position on server-rendered pages.\r\n        this._restoreScrollRestoration();\r\n      } else {\r\n        this._setScrollRestoration();\r\n      }\r\n    };\r\n\r\n    PageLifecycle.addEventListener('statechange', this._pageLifecycleListener);\r\n  }\r\n\r\n  registerElement(key, element, shouldUpdateScroll, context) {\r\n    invariant(\r\n      !this._scrollElements[key],\r\n      'ScrollBehavior: There is already an element registered for `%s`.',\r\n      key,\r\n    );\r\n\r\n    const saveElementPosition = () => {\r\n      this._saveElementPosition(key);\r\n    };\r\n\r\n    const scrollElement = {\r\n      element,\r\n      shouldUpdateScroll,\r\n      savePositionHandle: null,\r\n\r\n      onScroll: () => {\r\n        if (!scrollElement.savePositionHandle && !this._ignoreScrollEvents) {\r\n          scrollElement.savePositionHandle = animationFrame.request(\r\n            saveElementPosition,\r\n          );\r\n        }\r\n      },\r\n    };\r\n\r\n    // In case no scrolling occurs, save the initial position\r\n    if (!scrollElement.savePositionHandle && !this._ignoreScrollEvents) {\r\n      scrollElement.savePositionHandle = animationFrame.request(\r\n        saveElementPosition,\r\n      );\r\n    }\r\n\r\n    this._scrollElements[key] = scrollElement;\r\n    element.addEventListener('scroll', scrollElement.onScroll);\r\n\r\n    this._updateElementScroll(key, null, context);\r\n  }\r\n\r\n  unregisterElement(key) {\r\n    invariant(\r\n      this._scrollElements[key],\r\n      'ScrollBehavior: There is no element registered for `%s`.',\r\n      key,\r\n    );\r\n\r\n    const { element, onScroll, savePositionHandle } = this._scrollElements[\r\n      key\r\n    ];\r\n\r\n    element.removeEventListener('scroll', onScroll);\r\n    animationFrame.cancel(savePositionHandle);\r\n\r\n    delete this._scrollElements[key];\r\n  }\r\n\r\n  updateScroll(prevContext, context) {\r\n    this._updateWindowScroll(prevContext, context).then(() => {\r\n      // Save the position immediately after navigation so that if no scrolling\r\n      //  occurs, there is still a saved position.\r\n      if (!this._saveWindowPositionHandle) {\r\n        this._saveWindowPositionHandle = animationFrame.request(\r\n          this._saveWindowPosition,\r\n        );\r\n      }\r\n    });\r\n\r\n    Object.keys(this._scrollElements).forEach((key) => {\r\n      this._updateElementScroll(key, prevContext, context);\r\n    });\r\n  }\r\n\r\n  _setScrollRestoration = () => {\r\n    if (this._oldScrollRestoration) {\r\n      // It's possible that we already set the scroll restoration.\r\n      return;\r\n    }\r\n    if (\r\n      'scrollRestoration' in window.history &&\r\n      // Unfortunately, Safari on iOS freezes for 2-6s after the user swipes to\r\n      //  navigate through history with scrollRestoration being 'manual', so we\r\n      //  need to detect this browser and exclude it from the following code\r\n      //  until this bug is fixed by Apple.\r\n      !isMobileSafari()\r\n    ) {\r\n      this._oldScrollRestoration = window.history.scrollRestoration;\r\n      try {\r\n        window.history.scrollRestoration = 'manual';\r\n      } catch (e) {\r\n        this._oldScrollRestoration = null;\r\n      }\r\n    }\r\n  };\r\n\r\n  _restoreScrollRestoration = () => {\r\n    /* istanbul ignore if: not supported by any browsers on Travis */\r\n    if (this._oldScrollRestoration) {\r\n      try {\r\n        window.history.scrollRestoration = this._oldScrollRestoration;\r\n      } catch (e) {\r\n        /* silence */\r\n      }\r\n      this._oldScrollRestoration = null;\r\n    }\r\n  };\r\n\r\n  stop() {\r\n    this._restoreScrollRestoration();\r\n\r\n    window.removeEventListener('scroll', this._onWindowScroll);\r\n    this._cancelCheckWindowScroll();\r\n\r\n    PageLifecycle.removeEventListener('statechange', this._pageLifecycleListener);\r\n\r\n    this._removeNavigationListener();\r\n  }\r\n\r\n  startIgnoringScrollEvents() {\r\n    this._ignoreScrollEvents = true;\r\n  }\r\n\r\n  stopIgnoringScrollEvents() {\r\n    this._ignoreScrollEvents = false;\r\n  }\r\n\r\n  _onWindowScroll = () => {\r\n    if (this._ignoreScrollEvents) {\r\n      // Don't save the scroll position until navigation is complete.\r\n      return;\r\n    }\r\n\r\n    // It's possible that this scroll operation was triggered by what will be a\r\n    //  `POP` navigation. Instead of updating the saved location immediately,\r\n    //  we have to enqueue the update, then potentially cancel it if we observe\r\n    //  a location update.\r\n    if (!this._saveWindowPositionHandle) {\r\n      this._saveWindowPositionHandle = animationFrame.request(\r\n        this._saveWindowPosition,\r\n      );\r\n    }\r\n\r\n    if (this._windowScrollTarget) {\r\n      const [xTarget, yTarget] = this._windowScrollTarget;\r\n      const x = scrollLeft(window);\r\n      const y = scrollTop(window);\r\n\r\n      if (x === xTarget && y === yTarget) {\r\n        this._windowScrollTarget = null;\r\n        this._cancelCheckWindowScroll();\r\n      }\r\n    }\r\n  };\r\n\r\n  _saveWindowPosition = () => {\r\n    this._saveWindowPositionHandle = null;\r\n\r\n    this._savePosition(null, window);\r\n  };\r\n\r\n  _cancelCheckWindowScroll() {\r\n    animationFrame.cancel(this._checkWindowScrollHandle);\r\n    this._checkWindowScrollHandle = null;\r\n  }\r\n\r\n  _saveElementPosition(key) {\r\n    const scrollElement = this._scrollElements[key];\r\n    scrollElement.savePositionHandle = null;\r\n\r\n    this._savePosition(key, scrollElement.element);\r\n  }\r\n\r\n  _savePosition(key, element) {\r\n    this._stateStorage.save(this._getCurrentLocation(), key, [\r\n      scrollLeft(element),\r\n      scrollTop(element),\r\n    ]);\r\n  }\r\n\r\n  _updateWindowScroll(prevContext, context) {\r\n    // Whatever we were doing before isn't relevant any more.\r\n    this._cancelCheckWindowScroll();\r\n\r\n    this._windowScrollTarget = this._getScrollTarget(\r\n      null,\r\n      this._shouldUpdateScroll,\r\n      prevContext,\r\n      context,\r\n    );\r\n\r\n    // Updating the window scroll position is really flaky. Just trying to\r\n    //  scroll it isn't enough. Instead, try to scroll a few times until it\r\n    //  works.\r\n    this._numWindowScrollAttempts = 0;\r\n    return this._checkWindowScrollPosition();\r\n  }\r\n\r\n  _updateElementScroll(key, prevContext, context) {\r\n    const { element, shouldUpdateScroll } = this._scrollElements[key];\r\n\r\n    const scrollTarget = this._getScrollTarget(\r\n      key,\r\n      shouldUpdateScroll,\r\n      prevContext,\r\n      context,\r\n    );\r\n    if (!scrollTarget) {\r\n      return;\r\n    }\r\n\r\n    // Unlike with the window, there shouldn't be any flakiness to deal with\r\n    //  here.\r\n    this.scrollToTarget(element, scrollTarget);\r\n  }\r\n\r\n  _getDefaultScrollTarget(location) {\r\n    const { hash } = location;\r\n    if (hash && hash !== '#') {\r\n      return hash.charAt(0) === '#' ? hash.slice(1) : hash;\r\n    }\r\n    return [0, 0];\r\n  }\r\n\r\n  _getScrollTarget(key, shouldUpdateScroll, prevContext, context) {\r\n    const scrollTarget = shouldUpdateScroll\r\n      ? shouldUpdateScroll.call(this, prevContext, context)\r\n      : true;\r\n\r\n    if (\r\n      !scrollTarget ||\r\n      Array.isArray(scrollTarget) ||\r\n      typeof scrollTarget === 'string'\r\n    ) {\r\n      return scrollTarget;\r\n    }\r\n\r\n    const location = this._getCurrentLocation();\r\n\r\n    return (\r\n      this._getSavedScrollTarget(key, location) ||\r\n      this._getDefaultScrollTarget(location)\r\n    );\r\n  }\r\n\r\n  _getSavedScrollTarget(key, location) {\r\n    if (location.action === 'PUSH') {\r\n      return null;\r\n    }\r\n\r\n    return this._stateStorage.read(location, key);\r\n  }\r\n\r\n  _checkWindowScrollPosition = () => {\r\n    this._checkWindowScrollHandle = null;\r\n\r\n    // We can only get here if scrollTarget is set. Every code path that unsets\r\n    //  scroll target also cancels the handle to avoid calling this handler.\r\n    //  Still, check anyway just in case.\r\n    /* istanbul ignore if: paranoid guard */\r\n    if (!this._windowScrollTarget) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    this.scrollToTarget(window, this._windowScrollTarget);\r\n\r\n    ++this._numWindowScrollAttempts;\r\n\r\n    /* istanbul ignore if: paranoid guard */\r\n    if (this._numWindowScrollAttempts >= MAX_SCROLL_ATTEMPTS) {\r\n      // This might happen if the scroll position was already set to the target\r\n      this._windowScrollTarget = null;\r\n      return Promise.resolve();\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n      this._checkWindowScrollHandle = animationFrame.request(() =>\r\n        resolve(this._checkWindowScrollPosition()),\r\n      );\r\n    });\r\n  };\r\n\r\n  scrollToTarget(element, target) {\r\n    if (typeof target === 'string') {\r\n      const targetElement =\r\n        document.getElementById(target) ||\r\n        document.getElementsByName(target)[0];\r\n      if (targetElement) {\r\n        targetElement.scrollIntoView();\r\n        return;\r\n      }\r\n\r\n      // Fallback to scrolling to top when target fragment doesn't exist.\r\n      target = [0, 0]; // eslint-disable-line no-param-reassign\r\n    }\r\n\r\n    const [left, top] = target;\r\n    scrollLeft(element, left);\r\n    scrollTop(element, top);\r\n  }\r\n}"],"mappings":"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"}