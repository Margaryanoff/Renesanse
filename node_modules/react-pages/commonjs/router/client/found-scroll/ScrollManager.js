"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollContext = void 0;
exports["default"] = ScrollManager;
var _farce = require("@catamphetamine/farce");
var _react = _interopRequireWildcard(require("react"));
var _index = _interopRequireDefault(require("../scroll-behavior/index.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// import StateStorage from '@catamphetamine/farce/StateStorage';
// import StateStorage from '@catamphetamine/farce/lib/esm/StateStorage.js';
// import StateStorage from '@catamphetamine/farce/lib/cjs/StateStorage.js';

// import ScrollBehavior from 'scroll-behavior';

var STORAGE_NAMESPACE = '@@scroll';
var ScrollContext = (0, _react.createContext)(null);
exports.ScrollContext = ScrollContext;
var defaultCreateScrollBehavior = function defaultCreateScrollBehavior(config) {
  return new _index["default"](config);
};

// Rewrote `<ScrollManager/>` from `found-scroll` in React hooks.
// Also fixed React strict mode bug.
// https://github.com/4Catalyzer/found-scroll/issues/382
function ScrollManager(_ref) {
  var renderArgs = _ref.renderArgs,
    shouldUpdateScrollProperty = _ref.shouldUpdateScroll,
    _ref$createScrollBeha = _ref.createScrollBehavior,
    createScrollBehavior = _ref$createScrollBeha === void 0 ? defaultCreateScrollBehavior : _ref$createScrollBeha,
    children = _ref.children;
  var router = renderArgs.router,
    location = renderArgs.location;
  var prevRenderArgs = (0, _react.useRef)(null);
  var scrollBehaviorRef = (0, _react.useRef)();
  var scrollBehavior = scrollBehaviorRef.current;
  var getCurrentLocation = (0, _react.useCallback)(function () {
    return location;
  }, [location]);
  var getCurrentLocationRef = (0, _react.useRef)();
  getCurrentLocationRef.current = getCurrentLocation;
  var _shouldUpdateScroll = (0, _react.useCallback)(function (prevRenderArgs, renderArgs) {
    if (!shouldUpdateScrollProperty) {
      return true;
    }
    // A hack to allow access to `ScrollBehavior` internals (e.g. `stateStorage`).
    return shouldUpdateScrollProperty.call(scrollBehavior, prevRenderArgs, renderArgs);
  }, [scrollBehavior]);
  var registerScrollElement = (0, _react.useCallback)(function (key, element) {
    scrollBehavior.registerElement(key, element, _shouldUpdateScroll, renderArgs);
    return function () {
      scrollBehavior.unregisterElement(key);
    };
  }, [_shouldUpdateScroll, scrollBehavior, renderArgs]);
  var scrollContext = (0, _react.useMemo)(function () {
    return {
      scrollBehavior: scrollBehavior,
      registerScrollElement: registerScrollElement
    };
  }, [scrollBehavior, registerScrollElement]);
  (0, _react.useEffect)(function () {
    var scrollBehavior = createScrollBehavior({
      addNavigationListener: router.addNavigationListener,
      stateStorage: new _farce.StateStorage(router, STORAGE_NAMESPACE),
      getCurrentLocation: function getCurrentLocation() {
        return getCurrentLocationRef.current();
      },
      shouldUpdateScroll: function shouldUpdateScroll(prevRenderArgs, renderArgs) {
        return _shouldUpdateScroll(prevRenderArgs, renderArgs);
      }
    });
    scrollBehaviorRef.current = scrollBehavior;
    return function () {
      scrollBehavior.stop();
    };
  }, []);
  (0, _react.useEffect)(function () {
    var scrollBehavior = scrollBehaviorRef.current;
    var prevLocation = prevRenderArgs.current && prevRenderArgs.current.location;
    if (renderArgs.location === prevLocation || !(renderArgs.elements || renderArgs.error)) {
      // If the location hasn't actually changed, or if we're in a global
      // pending state, don't update the scroll position.
      return;
    }
    scrollBehavior.updateScroll(prevRenderArgs.current, renderArgs);
    prevRenderArgs.current = renderArgs;
  });

  // return (
  //   <ScrollContext.Provider value={scrollContext}>
  //     {children}
  //   </ScrollContext.Provider>
  // );

  return _react["default"].createElement(ScrollContext.Provider, {
    value: scrollContext
  }, children);
}
//# sourceMappingURL=ScrollManager.js.map