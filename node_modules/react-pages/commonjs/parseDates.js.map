{"version":3,"file":"parseDates.js","names":["hours","minutes","hoursAndMinutesForMidnightUnconventional","seconds","milliseconds","time","timezone","year","month","day","IsoDatePattern","IsoDateRegExp","RegExp","parseDates","object","test","Date","Array","isArray","i","length","isObject","Object","keys","key"],"sources":["../lib/parseDates.js"],"sourcesContent":["import isObject from './isObject.js'\r\n\r\n// ISO 8601 date regular expression\r\n// Adapted from: http://stackoverflow.com/a/14322189/970769\r\n\r\nconst hours = '([01]\\\\d|2[0-3])'\r\nconst minutes = '[0-5]\\\\d'\r\nconst hoursAndMinutesForMidnightUnconventional = '24\\\\:00'\r\nconst seconds = '[0-5]\\\\d'\r\nconst milliseconds = '[\\\\d]{3}'\r\nconst time = `(${hours}\\\\:${minutes}|${hoursAndMinutesForMidnightUnconventional})\\\\:${seconds}\\\\.${milliseconds}`\r\n\r\nconst timezone = 'Z'\r\n\r\nconst year = '\\\\d{4}'\r\nconst month = '(0[1-9]|1[0-2])'\r\nconst day = '([12]\\\\d|0[1-9]|3[01])'\r\n\r\nexport const IsoDatePattern = `${year}-${month}-${day}T${time}${timezone}`\r\n\r\nconst IsoDateRegExp = new RegExp('^' + IsoDatePattern + '$')\r\n\r\n// JSON date deserializer.\r\n//\r\n// Automatically converts ISO serialized `Date`s\r\n// in JSON responses for Ajax HTTP requests.\r\n//\r\n// Without it the developer would have to convert\r\n// `Date` strings to `Date`s in Ajax HTTP responses manually.\r\n//\r\n// Use as the second, 'reviver' argument to `JSON.parse`: `JSON.parse(json, JSON.dateParser)`\r\n//\r\n// http://stackoverflow.com/questions/14488745/javascript-json-date-deserialization/23691273#23691273\r\n\r\n// Walks JSON object tree\r\nexport default function parseDates(object) {\r\n\t// If it's a date in an ISO string format, then parse it\r\n\tif (typeof object === 'string' && IsoDateRegExp.test(object)) {\r\n\t\tobject = new Date(object)\r\n\t}\r\n\t// If an array is encountered,\r\n\t// proceed recursively with each element of this array.\r\n\telse if (Array.isArray(object)) {\r\n\t\tlet i = 0\r\n\t\twhile (i < object.length) {\r\n\t\t\tobject[i] = parseDates(object[i])\r\n\t\t\ti++\r\n\t\t}\r\n\t}\r\n\t// If a child JSON object is encountered,\r\n\t// convert all of its `Date` string values to `Date`s,\r\n\t// and proceed recursively for all of its properties.\r\n\telse if (isObject(object)) {\r\n\t\tfor (const key of Object.keys(object)) {\r\n\t\t\t// proceed recursively\r\n\t\t\tobject[key] = parseDates(object[key])\r\n\t\t}\r\n\t}\r\n\r\n\t// Dates have been converted for this JSON object\r\n\treturn object\r\n}"],"mappings":";;;;;;;AAAA;AAAoC;AAEpC;AACA;;AAEA,IAAMA,KAAK,GAAG,kBAAkB;AAChC,IAAMC,OAAO,GAAG,UAAU;AAC1B,IAAMC,wCAAwC,GAAG,SAAS;AAC1D,IAAMC,OAAO,GAAG,UAAU;AAC1B,IAAMC,YAAY,GAAG,UAAU;AAC/B,IAAMC,IAAI,cAAOL,KAAK,gBAAMC,OAAO,cAAIC,wCAAwC,iBAAOC,OAAO,gBAAMC,YAAY,CAAE;AAEjH,IAAME,QAAQ,GAAG,GAAG;AAEpB,IAAMC,IAAI,GAAG,QAAQ;AACrB,IAAMC,KAAK,GAAG,iBAAiB;AAC/B,IAAMC,GAAG,GAAG,wBAAwB;AAE7B,IAAMC,cAAc,aAAMH,IAAI,cAAIC,KAAK,cAAIC,GAAG,cAAIJ,IAAI,SAAGC,QAAQ,CAAE;AAAA;AAE1E,IAAMK,aAAa,GAAG,IAAIC,MAAM,CAAC,GAAG,GAAGF,cAAc,GAAG,GAAG,CAAC;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACe,SAASG,UAAU,CAACC,MAAM,EAAE;EAC1C;EACA,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIH,aAAa,CAACI,IAAI,CAACD,MAAM,CAAC,EAAE;IAC7DA,MAAM,GAAG,IAAIE,IAAI,CAACF,MAAM,CAAC;EAC1B;EACA;EACA;EAAA,KACK,IAAIG,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,EAAE;IAC/B,IAAIK,CAAC,GAAG,CAAC;IACT,OAAOA,CAAC,GAAGL,MAAM,CAACM,MAAM,EAAE;MACzBN,MAAM,CAACK,CAAC,CAAC,GAAGN,UAAU,CAACC,MAAM,CAACK,CAAC,CAAC,CAAC;MACjCA,CAAC,EAAE;IACJ;EACD;EACA;EACA;EACA;EAAA,KACK,IAAI,IAAAE,oBAAQ,EAACP,MAAM,CAAC,EAAE;IAC1B,gCAAkBQ,MAAM,CAACC,IAAI,CAACT,MAAM,CAAC,kCAAE;MAAlC,IAAMU,GAAG;MACb;MACAV,MAAM,CAACU,GAAG,CAAC,GAAGX,UAAU,CAACC,MAAM,CAACU,GAAG,CAAC,CAAC;IACtC;EACD;;EAEA;EACA,OAAOV,MAAM;AACd"}