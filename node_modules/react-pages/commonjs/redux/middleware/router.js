"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = routerMiddleware;
var _actions = require("../../router/actions.js");
var _index = require("../../router/index.js");
var _mergeMeta = _interopRequireDefault(require("../../meta/mergeMeta.js"));
var _applyMeta = _interopRequireDefault(require("../../meta/applyMeta.js"));
var _getLocationUrl = _interopRequireDefault(require("../../getLocationUrl.js"));
var _shouldSkipLoadForNavigation = _interopRequireDefault(require("../load/shouldSkipLoadForNavigation.js"));
var _isSamePage = _interopRequireDefault(require("../../isSamePage.js"));
var _actions2 = require("../load/actions.js");
var _actions3 = require("../navigation/actions.js");
var _instantNavigation = require("../client/instantNavigation.js");
var _flags = require("../../client/flags.js");
var _context = require("../../context.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var ON_PAGE_LOADED_METHOD_NAME = 'onLoaded';

// Any events listened to here are being dispatched on client side.
function routerMiddleware(_ref) {
  var routes = _ref.routes,
    codeSplit = _ref.codeSplit,
    onBeforeNavigate = _ref.onBeforeNavigate,
    onNavigationFinished = _ref.onNavigationFinished,
    reportStats = _ref.reportStats,
    context = _ref.context,
    stash = _ref.stash;
  // `startedAt` is the time when the latest navigation has started.
  //
  // It gets updated when receiving a `UPDATE_MATCH` event
  // and then read when receiving a `RESOLVE_MATCH` event
  // to measure the time between `UPDATE_MATCH` and `RESOLVE_MATCH` events.
  //
  var startedAt;

  // This flag tells if the navigation is between different pages or not.
  // If it's not between different pages then `.load()` won't be called.
  //
  // It gets updated when receiving a `UPDATE_MATCH` event
  // and then read when receiving a `RESOLVE_MATCH` event.
  //
  var isNavigatingToAnotherPage;

  // `previousLocation` is the `location` the latest finished navigation.
  //
  // It gets updated when receiving a `RESOLVE_MATCH` event.
  //
  var previousLocation;

  // `previousRouteIndices` represents the full "path" to the `previousLocation` route.
  //
  var previousRouteIndices;
  return function (_ref2) {
    var dispatch = _ref2.dispatch,
      getState = _ref2.getState;
    return function (next) {
      return function (event) {
        // Skip the first pass of the initial client-side render.
        // for the case when server-side rendering is used.
        if ((0, _context.getFromContext)('InitialPage/RepeatingServerSideRenderOnClientSide')) {
          return next(event);
        }

        // `event.payload` is a `MatcherResult`/`MatchBase` object
        // in case of a `UPDATE_MATCH`/`RESOLVE_MATCH` event.
        // https://github.com/4Catalyzer/found/blob/master/src/typeUtils.ts
        var params = event.payload && event.payload.params;
        var location = event.payload && event.payload.location;
        var routeIndices = event.payload && event.payload.routeIndices;
        var routeParams = event.payload && event.payload.routeParams;

        // `UPDATE_MATCH` event is triggered when navigation has started (only on client side).
        // `RESOLVE_MATCH` event is triggered when navigation has ended and the new page will be rendered (only on client side).
        //
        switch (event.type) {
          case _actions.UPDATE_MATCH:
            // Store `event.payload` for the future `_UPDATE_MATCH` event.
            if (!(0, _context.getFromContext)('App/HasBeenRendered') && !(0, _flags.isServerSideLoaded)()) {
              (0, _context.setInContext)('InitialPage/FakeResolveMatchEventPayload', event.payload);
            }
            isNavigatingToAnotherPage = !previousLocation || !(0, _isSamePage["default"])(previousLocation, location);
            if (isNavigatingToAnotherPage) {
              // Measure `load` and `render` time.
              startedAt = Date.now();

              // If it's an instant "Back"/"Forward" navigation
              // then navigate to the page without loading it.
              // (has been previously loaded and is in Redux state)
              var _isInstantTransition = location.action === 'POP' && previousLocation && (0, _instantNavigation.isInstantTransition)(previousLocation, location);

              // Set the flag for `wasInstantNavigation()`.
              (0, _instantNavigation.setInstantNavigationFlag)(_isInstantTransition);

              // Indicates whether an `instantBack` `<Link/>` has been clicked.
              // (or if `goto()` has been called with `instantBack: true` option)
              var instantBack = (0, _instantNavigation.isNavigationWithInstantBackAbility)();

              // Update instant back navigation chain.
              if (instantBack) {
                // Stores "current" (soon to be "previous") location
                // in "instant back chain", so that if "Back" is clicked
                // then such transition could be detected as "should be instant".
                (0, _instantNavigation.addInstantBack)(location, previousLocation, routeIndices, previousRouteIndices);
              } else if (_isInstantTransition) {
                (0, _instantNavigation.updateInstantNavigationChainIndex)(location);
              } else {
                // If current transition is not "instant back" and not "instant"
                // then reset the whole "instant back" chain.
                // Only a consequitive "instant back" navigation chain
                // preserves the ability to instantly navigate "Back".
                // Once a regular navigation takes place
                // all previous "instant back" possibilities are discarded.
                (0, _instantNavigation.resetInstantNavigationChain)();
              }

              // Set the flag for `isInstantBackAbleNavigation()`.
              // `instantBack` is for a "forward" instant-back-able navigation.
              // `_isInstantTransition` is for a "backwards" instant-back-able navigation.
              (0, _context.setInContext)('Navigation/IsInstantBack', instantBack || _isInstantTransition);

              // Trigger "before navigate to another page" listeners.
              if ((0, _context.getFromContext)('Navigation/BeforeNavigateToAnotherPage')) {
                var routeChain = (0, _index.getRoutesByPath)(routeIndices, routes);
                var pageRoute = routeChain[routeChain.length - 1];
                var _iterator = _createForOfIteratorHelper((0, _context.getFromContext)('Navigation/BeforeNavigateToAnotherPage')),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var navigationStartListener = _step.value;
                    navigationStartListener({
                      location: location,
                      route: (0, _index.getRoutePath)((0, _index.getRoutesByPath)(routeIndices, routes)),
                      params: routeParams,
                      instantBack: (0, _context.getFromContext)('Navigation/IsInstantBack'),
                      navigationContext: (0, _context.getFromContext)('Navigation/Context')
                    });
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              (0, _context.clearInContext)('Navigation/BeforeNavigateToAnotherPage');

              // Trigger `onBeforeNavigate()` global listener.
              if (onBeforeNavigate) {
                onBeforeNavigate({
                  dispatch: dispatch,
                  useSelector: function useSelector(getter) {
                    return getter(getState());
                  },
                  location: location,
                  url: (0, _getLocationUrl["default"])(location),
                  params: params,
                  context: context
                });
              }
            }

            // `UPDATE_MATCH`/`RESOLVE_MATCH` events aren't triggered on server side.
            // They're only triggered on client side.
            // If there was an error while navigating to a new `location`,
            // the `load` function will catch that error and `dispatch()`
            // a `SET_NAVIGATION_LOCATION` action with the `previousLocation`.
            dispatch({
              type: _actions3.SET_NAVIGATION_LOCATION,
              location: location
            });

            // If someone requires something like `useNavigationRoute()` hook in some future:
            // dispatch({ type: SET_NAVIGATION_ROUTE, { location, params, path: getRoutePath(getRoutesByPath(routeIndices, routes)) } })

            // Show page loading indicator.
            if ((0, _flags.isServerSideLoaded)()) {
              // Show page loading indicator.
              dispatch({
                type: _actions2.LOAD_STARTED,
                location: location
              });
            } else {
              if ((0, _context.getFromContext)('App/HasBeenRendered')) {
                // Show page loading indicator.
                dispatch({
                  type: _actions2.LOAD_STARTED,
                  location: location
                });
              } else {
                // The application React element doesn't get rendered
                // until the initial `load()` has finished.
                // Therefore, the usual "show loading during navigation"
                // component won't be rendered too.
                // Use `InitialLoadComponent` configuration parameter
                // to show a loading indicator during the initial load.
                //
                // `LOAD_STARTED` event is not dispatched
                // because there's no one listening to Redux state changes yet.
                //
                // `SET_NAVIGATION_LOCATION` event has been dispatched
                // to set `navigationLocation` property in Redux state.
              }
            }
            break;

          // `UPDATE_MATCH` event is triggered when navigation starts (only on client side).
          // `RESOLVE_MATCH` event is triggered when navigation ends (only on client side).
          //
          // In `found` router, `RESOLVE_MATCH` is not being dispatched
          // for the first render for some weird reason.
          // https://github.com/4Catalyzer/found/issues/202
          //
          // With server-side rendering enabled,
          // initially there are two rendering passes
          // and therefore `RESOLVE_MATCH` does get dispatched
          // after the page is initialized and rendered,
          // so there's no need to work around `RESOLVE_MATCH`
          // not being dispatched (because it is dispatched).
          //
          // With server-side rendering disabled,
          // `RESOLVE_MATCH` does not get dispatched,
          // therefore a custom `_RESOLVE_MATCH` event is
          // dispatched manually to mimick a `RESOLVE_MATCH` event.
          //
          case _actions.RESOLVE_MATCH:
          case _actions._RESOLVE_MATCH:
            if ((0, _context.takeFromContext)('Navigation/IgnoreResolveMatchRouterEvent')) {
              break;
            }

            // `routeIndices` might be `undefined` after a `<Redirect/>`
            // is made and a user clicks the "Back" button in a web browser.
            // https://github.com/4Catalyzer/found/issues/632
            if (!routeIndices) {
              throw new Error("\"".concat(event.type, "\" Redux action misses \"routeIndices\" property. This usually means that the target URL path \"").concat(location.pathname, "\" didn't match any route. ").concat(location.pathname[0] !== '/' ? 'The target URL path is missing a leading slash: correct your routes configuration to include a leading slash for "' + location.pathname + '" path. ' : '', "See the issue for more info: https://github.com/4Catalyzer/found/issues/632"));
            }
            if (!(0, _context.getFromContext)('App/HasBeenRendered')) {
              (0, _context.setInContext)('App/HasBeenRendered', true);
            }
            (0, _context.setInContext)('Navigation/PreviousRoutes', routeIndices);
            (0, _context.setInContext)('Navigation/PreviousRoutesParameters', routeParams);
            previousLocation = location;
            previousRouteIndices = routeIndices;
            if (isNavigatingToAnotherPage) {
              // Call `onLoaded()` function of the page `Component`.
              if (!codeSplit) {
                var _routeChain = (0, _index.getRoutesByPath)(routeIndices, routes);
                var _pageRoute = _routeChain[_routeChain.length - 1];
                // Routes don't have `.Component` property
                // set when using `codeSplit` feature.
                var onPageLoaded = _pageRoute.Component[ON_PAGE_LOADED_METHOD_NAME];
                if (onPageLoaded) {
                  onPageLoaded({
                    dispatch: dispatch,
                    useSelector: function useSelector(getter) {
                      return getter(getState());
                    },
                    location: location
                  });
                }
              }

              // Update `<meta/>` tags.
              updateMetaTags({
                routes: routes,
                routeIndices: routeIndices,
                useSelector: function useSelector(getter) {
                  return getter(getState());
                },
                codeSplit: codeSplit,
                stash: stash
              });

              // Set "initial `<meta/>` has been applied" flag.
              if (!(0, _context.getFromContext)('App/InitialMetaHasBeenApplied')) {
                (0, _context.setInContext)('App/InitialMetaHasBeenApplied', true);
              }

              // Call `onNavigationFinished()` global listener.
              if (onNavigationFinished) {
                onNavigationFinished({
                  url: (0, _getLocationUrl["default"])(location),
                  location: location,
                  params: params,
                  context: context,
                  dispatch: dispatch,
                  useSelector: function useSelector(getter) {
                    return getter(getState());
                  }
                });
              }

              // Report page loading time.
              // This loading time will be longer then
              // the server-side one, say, by 10 milliseconds,
              // probably because the web browser making
              // an asynchronous HTTP request is slower
              // than the Node.js server making a regular HTTP request.
              // Also this includes network latency
              // for a particular website user, etc.
              // So this `load` time doesn't actually describe
              // the server-side performance.
              if (reportStats) {
                reportStats({
                  url: (0, _getLocationUrl["default"])(location),
                  // Concatenated route `path` string.
                  // E.g. "/user/:user_id/post/:post_id"
                  route: (0, _index.getRoutePath)((0, _index.getRoutesByPath)(routeIndices, routes)),
                  time: {
                    loadAndRender: Date.now() - startedAt
                  }
                });
              }

              // Report loading time in console for debugging.
              if (Date.now() - startedAt > 30) {
                console.log("[react-pages] \"".concat(location.pathname, "\" loaded and rendered in ").concat(Date.now() - startedAt, " ms"));
              }
            }

            // Hide page loading indicator.
            dispatch({
              type: _actions2.LOAD_FINISHED
            });

            // It could clear `startedAt` value here but that wouldn't work in all cases.
            // For example, if there's an error thrown from the `load()` function of the page,
            // `RESOLVE_MATCH` event wouldn't be emitted.
            //
            // startedAt = undefined

            break;
        }
        return next(event);
      };
    };
  };
}
function updateMetaTags(_ref3) {
  var routes = _ref3.routes,
    routeIndices = _ref3.routeIndices,
    useSelector = _ref3.useSelector,
    codeSplit = _ref3.codeSplit,
    stash = _ref3.stash;
  var routeChain = (0, _index.getRoutesByPath)(routeIndices, routes);
  var pageRoute = routeChain[routeChain.length - 1];
  var meta = (0, _mergeMeta["default"])({
    rootMeta: codeSplit ? routes[0].meta : routes[0].Component.meta,
    pageMeta: codeSplit ? pageRoute.meta : pageRoute.Component.meta,
    useSelector: useSelector,
    stash: stash
  });

  // Update `<meta/>`.
  (0, _applyMeta["default"])(meta);
}
//# sourceMappingURL=router.js.map