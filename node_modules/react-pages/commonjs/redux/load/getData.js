"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getData;
var _getLocationUrl = _interopRequireDefault(require("../../getLocationUrl.js"));
var _index = require("../../router/index.js");
var _actions = require("../../router/actions.js");
var _context = require("../../context.js");
var _clearNavigationState = _interopRequireDefault(require("../../router/clearNavigationState.js"));
var _shouldSkipLoadForNavigation = _interopRequireDefault(require("./shouldSkipLoadForNavigation.js"));
var _load = _interopRequireDefault(require("./load.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function getData(_ref) {
  var routes = _ref.routes,
    routePosition = _ref.routePosition,
    params = _ref.params,
    dispatch = _ref.dispatch,
    getState = _ref.getState,
    codeSplit = _ref.codeSplit,
    server = _ref.server,
    onError = _ref.onError,
    getLocale = _ref.getLocale,
    getCookie = _ref.getCookie,
    context = _ref.context,
    stash = _ref.stash;
  var getReturnResult = function getReturnResult() {
    if (routePosition === 'root') {
      // Don't reset the properties for the root route component
      // because the root route component is always the same one
      // in any subsequent (non-initial) navigation,
      // and it's only being loaded once — at the initial load —
      // and any subsequent (non-initial) navigations will return `undefined` from `load()`.
      if (stash.getRootRouteComponentProps()) {
        return {
          props: stash.getRootRouteComponentProps()
        };
      }
    }
  };

  // Optionally skip loading data on client side.
  if (!server) {
    if ((0, _context.getFromContext)('InitialPage/SkipLoad') || (0, _context.getFromContext)('Navigation/SkipLoad') || (0, _context.getFromContext)('Page/HotReloadInProgress')) {
      if (routePosition === 'leaf') {
        // Reset "skip `load`" flag that was previously set
        // by `pushLocation()` or `replaceLocation()`.
        (0, _context.clearInContext)('Navigation/SkipLoad');
      }
      return getReturnResult();
    }
  }
  var _getLocations = getLocations(getState()),
    location = _getLocations.location,
    previousLocation_ = _getLocations.previousLocation;
  var isInitialClientSidePageLoad = !server && !previousLocation_;
  var previousLocation = isInitialClientSidePageLoad ? undefined : previousLocation_;

  // A workaround for `found` router bug:
  // https://github.com/4Catalyzer/found/issues/239
  // Prevent executing `load`s on "anchor" link click.
  if (!server && !isInitialClientSidePageLoad) {
    if ((0, _shouldSkipLoadForNavigation["default"])(previousLocation, location)) {
      return getReturnResult();
    }
  }

  // Execute `load`s.
  return (0, _load["default"])({
    location: location,
    previousLocation: previousLocation,
    routerArgs: {
      routes: (0, _index.getMatchedRoutes)(getState(), routes),
      routeIndices: (0, _index.getMatchedRoutesIndices)(getState()),
      routeParams: (0, _index.getMatchedRoutesParams)(getState()),
      params: (0, _index.getRouteParams)(getState())
    },
    routePosition: routePosition,
    codeSplit: codeSplit,
    server: server,
    getCookie: getCookie,
    getLocale: getLocale,
    context: context,
    dispatch: dispatch,
    useSelector: function useSelector(getter) {
      return getter(getState());
    }
  }).then(function (result) {
    // Anything that gets returned from this `getData()` function
    // gets passed to the page component as a `data` property.
    switch (routePosition) {
      case 'root':
        // `result` will be undefined for "root" route position
        // for any subsequent (non-initial) navigation.
        if (result) {
          stash.setRootRouteComponentProps(result.props);
        } else {
          // Don't reset the properties for the root route component
          // because the root route component is always the same one
          // in any subsequent (non-initial) navigation,
          // and it's only being loaded once — at the initial load —
          // and any subsequent (non-initial) navigations will return `undefined` from `load()`.
          result = getReturnResult();
        }
        break;
      case 'leaf':
        if (result) {
          stash.setPageRouteComponentProps(result.props);
        } else {
          // Reset the properties for the page route component
          // because the page component is now different from the previous one.
          stash.setPageRouteComponentProps(undefined);
        }
        break;
      default:
        throw new Error("[react-pages] Unsupported route position: \"".concat(routePosition, "\""));
    }
    return result;
  }, function (error) {
    // Clear any navigation-related context info
    // because the navigation is cancelled now.
    (0, _clearNavigationState["default"])();

    // Possibly handle the error (for example, redirect to an error page).
    //
    // The `instanceof RedirectException` check here prevents handling of
    // `dispatch(goto())` / `dispatch(redirect())` when those were called
    // from `.load()` functions, because when called from `.load()` functions,
    // dispatching those two actions throws a `RedirectException`.
    //
    if (error instanceof _index.RedirectException) {
      throw error;
    }
    try {
      if (onError) {
        onError(error, {
          location: location,
          url: (0, _getLocationUrl["default"])(location),
          // Using `redirect` instead of `goto` here
          // so that the user can't go "Back" to the page being loaded
          // in case of an error because it would be in inconsistent state
          // due to `load` being interrupted.
          redirect: function redirect(to) {
            // `to` can be a `string`.
            //
            // 307 Temporary Redirect
            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307
            // 308 Permanent Redirect
            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308
            //
            var redirectStatusCode = undefined;
            throw new _index.RedirectException(to, redirectStatusCode);
          },
          dispatch: dispatch,
          useSelector: function useSelector(getter) {
            return getter(getState());
          },
          server: server
        });
      }

      // If no `redirect()` was called in `onLoadError()` handler,
      // it should redirect anyway because the new location wasn't loaded
      // but the new location's URL is still in the web browser's address bar,
      // so that URL should be replaced with some other one.
      // In this case, this is gonna be the previous location's URL.
      var redirectStatusCode = undefined;
      throw new _index.RedirectException(previousLocation, redirectStatusCode);
    } catch (error) {
      if (error instanceof _index.RedirectException) {
        throw error;
      }

      // Here it handles any non-redirect errors thrown from `.load()` functions.
      // If no `redirect()` was called in `onLoadError()` handler,
      // it should redirect anyway because the new location wasn't loaded
      // but the new location's URL is still in the web browser's address bar,
      // so that URL should be replaced with some other one.
      // In this case, this is gonna be the previous location's URL.
      console.error(error);
      var _redirectStatusCode = undefined;
      throw new _index.RedirectException(previousLocation, _redirectStatusCode);
    }
  });
}
function getLocations(state) {
  var server = typeof window === 'undefined';
  return {
    location: (0, _index.getMatchedLocation)(state),
    previousLocation: server || !(0, _context.getFromContext)('App/HasBeenRendered') ? undefined : (0, _index.getMatchedLocationThatHasBeenLoaded)(state)
  };
}
//# sourceMappingURL=getData.js.map