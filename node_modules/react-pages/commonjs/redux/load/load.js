"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LOAD_METHOD_NAME = void 0;
exports.collectLoadFunctionsFromComponents = collectLoadFunctionsFromComponents;
exports["default"] = load_;
var _isEqual = _interopRequireDefault(require("lodash/isEqual.js"));
var _index = require("../../router/index.js");
var _clearNavigationState = _interopRequireDefault(require("../../router/clearNavigationState.js"));
var _actions = require("../../router/actions.js");
var _getRoutePath = _interopRequireDefault(require("../../router/getRoutePath.js"));
var _context = require("../../context.js");
var _instantNavigation = require("../client/instantNavigation.js");
var _combine = _interopRequireDefault(require("./combine.js"));
var _restrictDispatchToPageState = _interopRequireDefault(require("./restrictDispatchToPageState.js"));
var _actions2 = require("./actions.js");
var _excluded = ["load"],
  _excluded2 = ["load"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// import { SET_NAVIGATION_LOCATION } from '../navigation/actions.js'

var LOAD_METHOD_NAME = 'load';
exports.LOAD_METHOD_NAME = LOAD_METHOD_NAME;
function load_(_ref) {
  var location = _ref.location,
    previousLocation = _ref.previousLocation,
    routePosition = _ref.routePosition,
    routerArgs = _ref.routerArgs,
    codeSplit = _ref.codeSplit,
    server = _ref.server,
    getCookie = _ref.getCookie,
    getLocale = _ref.getLocale,
    context = _ref.context,
    dispatch = _ref.dispatch,
    useSelector = _ref.useSelector;
  // If it's an instant "Back"/"Forward" navigation
  // then navigate to the page without loading it.
  // (has been previously loaded and is in Redux state)
  var isInstant = isInstantTransition_({
    location: location,
    previousLocation: previousLocation,
    server: server
  });

  // Preload status object.
  // `loading` holds the cancellation flag for this navigation process.
  // (e.g. loading `Promise` chain could be cancelled in case of a redirect)
  var loading = {};

  // Can cancel previous loading (on the client side)
  var previousPreloading;
  if (!server) {
    // This key is not set with `Page/` prefix in order to not be cleared
    // when another page starts loading.
    previousPreloading = (0, _context.getFromContext)('App/PageLoading');
    (0, _context.setInContext)('App/PageLoading', loading);
  }
  if (!server) {
    // If on the client side, then store the current pending navigation,
    // so that it can be cancelled when a new navigation process takes place
    // before the current navigation process finishes.
    //
    // If there's preceeding navigation pending,
    // then cancel that previous navigation.
    if (previousPreloading && previousPreloading.pending && !previousPreloading.cancelled) {
      previousPreloading.cancel();
    }
  }
  var routes = routerArgs.routes,
    params = routerArgs.params;

  // Instrument `dispatch`.
  // `dispatch` for server side `throw`s a special "redirect error" on redirect.
  // `dispatch` for client side cancels current `load` on redirect.
  dispatch = addNavigationActionsSupportToDispatch(dispatch, server, loading);

  // Removed the restriction because there're valid real-world cases
  // when a `.load()` function could update state outside of the page state.
  //
  // // Detects changes to state when `dispatch()`ing actions from a `.load()` function.
  // // If there were any, those changes must've been done to "page state" parts of the Redux state.
  // // "Page state" parts of the Redux state should be declared in the settings in `pageStateReducerNames` parameter.
  // // The rationale is that it fixes the potential bugs appearing in page components
  // // when the parts of the Redux state they use unexpectedly get refreshed before navigating to another page.
  // if (!server && routePosition !== 'root') {
  // 	dispatch = restrictDispatchToPageState(dispatch, { useSelector })
  // }

  var history = getHistory({
    server: server
  }).concat(createHistoryEntry({
    routes: routes,
    location: location
  }));

  // Preload all the required data for this route (page)
  var combinedLoadFunction;
  if (!isInstant) {
    var routeParams = routerArgs.routeParams,
      routeIndices = routerArgs.routeIndices;
    var loaders = getLoadFunctions({
      routes: routes,
      routePosition: routePosition,
      routeParams: routeParams,
      routeIndices: routeIndices,
      codeSplit: codeSplit,
      server: server
    });
    var isInitialClientSideLoad = !server && !previousLocation;
    combinedLoadFunction = (0, _combine["default"])(loaders, server, isInitialClientSideLoad, useSelector, dispatch, location, params, history, context, getCookie, loading);
  }

  // If nothing to load, just move to the next middleware
  if (!combinedLoadFunction) {
    return Promise.resolve();
  }
  var promise = combinedLoadFunction();
  loading.pending = true;

  // Preloading process cancellation
  loading.cancel = function () {
    loading.cancelled = true;
    // If `bluebird` is used,
    // and promise cancellation has been set up,
    // then cancel the `Promise`.
    // http://bluebirdjs.com/docs/api/cancellation.html
    if (promise.cancel) {
      // `.catch()` is to suppress "Uncaught promise rejection" errors
      promise["catch"](function () {}).cancel();
    }
  };
  return promise.then(
  // Navigate to the new page
  function (result) {
    loading.pending = false;
    // If this navigation process was cancelled
    // before `load` finished its work,
    // then don't take any further steps on this cancelled navigation.
    if (loading.cancelled) {
      // Return `false` out of the `Promise`
      // indicating that the navigation was cancelled.
      return false;
    }
    setHistory(history, {
      server: server
    });
    return result;
  }, function (error) {
    // If this navigation process was cancelled
    // before `load` finished its work,
    // then don't take any further steps on this cancelled navigation.
    if (!loading.cancelled) {
      if (!server) {
        loading.error = error;
      }
      // Emit loading error event.
      // Page loading indicator listens to it in order to become hidden.
      dispatch({
        type: _actions2.LOAD_FAILED,
        error: error
      });

      // This "go to previous page" code turned out not to work:
      // when `onError()` handler of `.load()` function
      // called `redirect()` function, it also resulted in a navigation,
      // and the two navigations conflicted with one another.
      // For example, this `navigateThroughHistory()` function call
      // was setting `Navigation/SkipLoad` flag to `true`
      // and that caused the next navigation via `redirect()` to not execute its `.load()`.
      //
      // // Revert the URL in the web browser's address bar
      // // to be the one for the "previous" location
      // // due to the process of navigating to the new location throwing an error.
      // if (previousLocation) {
      // 	dispatch(navigateThroughHistory(-1, { load: false }))
      // }

      // It doesn't dispatch `SET_NAVIGATION_LOCATION` action here
      // to reset the "navigation location" to the `previousLocation`
      // because that's supposed to be done in `lib/redux/load/getData.js`
      // by performing a forced redirect to the `previousLocation`.
      //
      // if (previousLocation) {
      // 	// Set `navigationLocation` to the "previous" (currently open) one
      // 	// instead of the "next" (was being loaded) one.
      // 	dispatch({ type: SET_NAVIGATION_LOCATION, location: previousLocation })
      // 	// If someone requires something like `useNavigationRoute()` hook in some future,
      // 	// it would have to also reset such "navigation route" to the previous one:
      // 	// dispatch({ type: SET_NAVIGATION_ROUTE, { location: previousLocation, params: previousParams, path: getRoutePath(previousRoutes) } })
      // }
    }

    // Update load status object.
    loading.pending = false;

    // May be a server-side special "redirect" error.
    throw error;
  });
}

// Instrument `dispatch`.
// `dispatch` for server side `throw`s a special "redirect error" on redirect.
// `dispatch` for client side cancels current `load` on redirect.
function addNavigationActionsSupportToDispatch(dispatch, server, loading) {
  return function (event) {
    switch (event.type) {
      // In case of navigation from `load`.
      case _actions.REDIRECT_ACTION_TYPE:
      case _actions.GOTO_ACTION_TYPE:
        // Discard the currently ongoing loading.
        // (if some kind of a `bluebird` is used in place of `Promise`)
        if (loading.cancel) {
          loading.cancel();
        }

        // Clear any navigation-related context info
        // because it's gonna be a new (unrelated) navigation
        // as part of the upcoming redirect.
        (0, _clearNavigationState["default"])();

        // if (!server && getFromContext('Navigation/SkipLoad')) {
        // 	console.warn('Looks like you\'re calling `dispatch(pushLocation())` or `dispatch(replaceLocation())` inside `load`. Call them in `onLoaded()` instead.')
        // }
        // 307 Temporary Redirect
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307
        // 308 Permanent Redirect
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308
        var redirectStatusCode = undefined;
        throw new _index.RedirectException(event.payload, redirectStatusCode);
      default:
        // Proceed normally.
        return dispatch(event);
    }
  };
}

// Finds all `load` methods
// (they will be executed in parallel).
//
// Parameter — components - the `Component`s of the matched routes chain.
//
// Returns an array of `componentLoaders`.
// `componentLoaders` is an array of all
// `load`s for a particular React component:
// objects having shape `{ load(), options }`.
// Therefore the returned value is an array of arrays.
//
function collectLoadFunctionsFromComponents(components) {
  // Find all static `load` methods on the route component chain
  return components
  // Some wrapper routes can have no `component`.
  // Select all components having `load`s.
  .filter(function (component) {
    return component && component[LOAD_METHOD_NAME];
  })
  // Extract `load` functions and their options.
  .map(function (component) {
    return normalizeLoadFunction(component[LOAD_METHOD_NAME]).map(function (_ref2) {
      var load = _ref2.load,
        rest = _objectWithoutProperties(_ref2, _excluded);
      return {
        load: load,
        options: rest
      };
    });
  });
  // // Flatten `load` functions and their options.
  // .reduce((all, load_and_options) => all.concat(load_and_options), [])
}

function collectLoadFunctionsFromRoutes(routes) {
  // Find all `.load()` properties on the route chain.
  return routes.map(function (_) {
    return _.load;
  }).filter(function (_) {
    return _;
  }).map(function (load) {
    return normalizeLoadFunction(load).map(function (_ref3) {
      var load = _ref3.load,
        rest = _objectWithoutProperties(_ref3, _excluded2);
      return {
        load: load,
        options: rest
      };
    });
  });
  // Flatten the array.
  // .reduce((all, load_and_options) => all.concat(load_and_options), [])
}

// A minor optimization for skipping `load`s
// for those parent routes which haven't changed
// as a result of a client-side navigation.
//
// On client side:
//
// Take the previous route components
// (along with their parameters)
// and the next route components
// (along with their parameters),
// and compare them side-by-side
// filtering out the same top level components
// (both having the same component classes
//  and having the same parameters).
//
// Therefore `load`s could be skipped
// for those top level components which remain
// the same (and in the same state).
// This would be an optimization.
//
// (e.g. the main route could be `load`ed only once - on the server side)
//
// At the same time, at least one component should be loaded:
// even if navigating to the same page it still kinda makes sense to reload it.
// (assuming it's not an "anchor" hyperlink navigation)
//
// Also, GET query parameters would also need to be compared, I guess.
// But, I guess, it would make sense to assume that GET parameters
// only affect the last routes component in the chain.
// And, in general, GET query parameters should be avoided,
// but that's not the case for example with search forms.
// So here we assume that GET query parameters only
// influence the last route component in the chain
// which is gonna be reloaded anyway.
//
function ignoreUnchangedRoutes(items, routes, routeParams, previousRoutes, previousRoutesParameters) {
  if (previousRoutes) {
    var i = 0;
    while (i < routes.length - 1 && previousRoutes[i] === routes[i] && (0, _isEqual["default"])(previousRoutesParameters[i], routeParams[i])) {
      i++;
    }
    return items.slice(i);
  }
  return items;
}
function normalizeLoadFunction(load) {
  if (typeof load === 'function') {
    load = {
      load: load
    };
  }
  if (!Array.isArray(load)) {
    load = [load];
  }
  return load;
}
function getHistory(_ref4) {
  var server = _ref4.server;
  if (server) {
    return [];
  }
  // This `NavigationHistory` is just a log of all navigation actions
  // performed by the user since they've opened the browser tab.
  // It's stored under `App/` just so that it doesn't get cleared
  // if there was an error during initial client-side render.
  return (0, _context.getFromContext)('App/NavigationHistory') || [];
}
function setHistory(history, _ref5) {
  var server = _ref5.server;
  if (server) {
    return;
  }
  // This `NavigationHistory` is just a log of all navigation actions
  // performed by the user since they've opened the browser tab.
  // It's stored under `App/` just so that it doesn't get cleared
  // if there was an error during initial client-side render.
  (0, _context.setInContext)('App/NavigationHistory', history);
}
function createHistoryEntry(_ref6) {
  var routes = _ref6.routes,
    location = _ref6.location;
  return {
    // A complete `path` for matched route chain.
    // E.g. "/user/:userId/post/:postId"
    // for matched URL "/user/1/post/123?key=value".
    route: (0, _getRoutePath["default"])(routes),
    action: getHistoryAction(location)
  };
}
function getHistoryAction(location) {
  if (location.index === 0) {
    return 'start';
  } else if (location.action === 'POP') {
    return location.delta === -1 ? 'back' : 'forward';
  } else if (location.action === 'PUSH') {
    return 'push';
  } else if (location.action === 'REPLACE') {
    return 'redirect';
  } else {
    console.error('[react-pages] Couldn\'t get a history entry action for location');
    console.log(location);
  }
}
function isInstantTransition_(_ref7) {
  var location = _ref7.location,
    previousLocation = _ref7.previousLocation,
    server = _ref7.server;
  // If it's a "Back"/"Forward" navigation
  var isBackOrForwardNavigation = location.action === 'POP' && location.delta !== 0 &&
  // During server-side rendering, `action` is "POP" and `delta` is `0`.
  !server;

  // If it's an instant "Back"/"Forward" navigation
  // then navigate to the page without loading it.
  // (has been previously loaded and is in Redux state)
  return isBackOrForwardNavigation && (0, _instantNavigation.isInstantTransition)(previousLocation, location);
}
function getLoadFunctions(_ref8) {
  var routes = _ref8.routes,
    routePosition = _ref8.routePosition,
    routeParams = _ref8.routeParams,
    routeIndices = _ref8.routeIndices,
    codeSplit = _ref8.codeSplit,
    server = _ref8.server;
  var rootRoute = routes[0];

  // Client-side optimization.
  // Skips `load`s for routes that didn't change as a result of navigation.
  if (!server) {
    var previousRoutes = (0, _context.getFromContext)('Navigation/PreviousRoutes');
    var previousRoutesParameters = (0, _context.getFromContext)('Navigation/PreviousRoutesParameters');
    routes = ignoreUnchangedRoutes(routes, routeIndices, routeParams, previousRoutes, previousRoutesParameters);
  }

  // In older versions of this library, it was possible to assign a `.load()` function
  // to all `Component`s in a route chain for a given URL.
  // Later it was decided that a simpler structure with just the last `Component`
  // in the route chain having a `.load()` function is more convenient.
  // Because of that, there's really no more "chain" but rather just the last `Component`'s
  // `.load()` function and optionally a configurable "pre" `load()` function from `react-pages.js`
  // configuration file that gets executed before the `Component`'s `.load()` function.

  switch (routePosition) {
    case 'root':
      // If the "root" route is still considered for collecting `.load()` functions,
      // then use only its `.load()` function. Otherwise, no `.load()` function.
      routes = routes[0] === rootRoute ? [rootRoute] : [];
      break;
    case 'leaf':
      routes = [routes[routes.length - 1]];
      break;
    default:
      throw new Error("Unsupported route position: \"".concat(routePosition, "\""));
  }

  // Get all `load` functions in the route components chain.
  var collectLoadFunctions = function collectLoadFunctions() {
    if (codeSplit) {
      return collectLoadFunctionsFromRoutes(routes);
    } else {
      return collectLoadFunctionsFromComponents(routes.map(function (_) {
        return _.Component;
      }));
    }
  };
  var loadFunctions = collectLoadFunctions();

  // Add `navigationContext` parameter to the "leaf" loading function.
  if (!server) {
    if (routePosition === 'leaf') {
      if (loadFunctions.length > 0) {
        var leafComponentLoaders = loadFunctions[loadFunctions.length - 1];
        loadFunctions[loadFunctions.length - 1] = leafComponentLoaders.map(function (loader) {
          return _objectSpread(_objectSpread({}, loader), {}, {
            load: function load(parameters) {
              return loader.load(_objectSpread(_objectSpread({}, parameters), {}, {
                navigationContext: (0, _context.getFromContext)('Navigation/Context')
              }));
            }
          });
        });
      }
    }
  }
  return loadFunctions;
}
//# sourceMappingURL=load.js.map