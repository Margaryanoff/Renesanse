"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = createGetDataForPreload;
var _getLocationUrl = _interopRequireDefault(require("../../getLocationUrl.js"));
var _index = require("../../router/index.js");
var _shouldSkipPreloadForNavigation = _interopRequireDefault(require("./shouldSkipPreloadForNavigation.js"));
var _preload = _interopRequireDefault(require("./preload.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function createGetDataForPreload(codeSplit, server, onError, getLocale, getConvertedRoutes, getCookie) {
  return function (_ref) {
    var params = _ref.params,
      _ref$context = _ref.context,
      dispatch = _ref$context.dispatch,
      getState = _ref$context.getState;
    if (!server) {
      if (window._ReactPages_Page_SkipDataLoad || window._ReactPages_Page_SkipDataLoad_on_navigation || window._ReactPages_Page_HotReloadInProgress) {
        // Reset "skip `load`" flag for `pushLocation()` and `replaceLocation()`.
        if (window._ReactPages_Page_SkipDataLoad_on_navigation) {
          window._ReactPages_Page_SkipDataLoad_on_navigation = false;
        }
        return;
      }
    }
    var _getLocations = getLocations(getState()),
      location = _getLocations.location,
      previousLocation = _getLocations.previousLocation;
    var isInitialClientSideNavigation = !server && !previousLocation;
    // A workaround for `found` router bug:
    // https://github.com/4Catalyzer/found/issues/239
    // Prevent executing `load`s on "anchor" link click.
    if (!server && !isInitialClientSideNavigation) {
      if ((0, _shouldSkipPreloadForNavigation["default"])(previousLocation, location)) {
        return;
      }
    }
    // Execute `load`s.
    return (0, _preload["default"])(location, isInitialClientSideNavigation ? undefined : previousLocation, {
      routes: (0, _index.getMatchedRoutes)(getState(), getConvertedRoutes()),
      routeIndices: (0, _index.getMatchedRoutesIndices)(getState()),
      routeParams: (0, _index.getMatchedRoutesParams)(getState()),
      params: (0, _index.getRouteParams)(getState())
    }, codeSplit, server, getCookie, getLocale, dispatch, getState).then(function (result) {
      return result;
    }, function (error) {
      // Possibly handle the error (for example, redirect to an error page).
      if (!(error instanceof _index.RedirectException)) {
        if (onError) {
          onError(error, {
            path: location.pathname,
            url: (0, _getLocationUrl["default"])(location),
            // Using `redirect` instead of `goto` here
            // so that the user can't go "Back" to the page being preloaded
            // in case of an error because it would be in inconsistent state
            // due to `load` being interrupted.
            redirect: function redirect(to) {
              // `to` can be a `string`.
              throw new _index.RedirectException(to);
            },
            dispatch: dispatch,
            getState: getState,
            server: server
          });
        }
      }
      throw error;
    });
  };
}
function getLocations(state) {
  var server = typeof window === 'undefined';
  return {
    location: (0, _index.getCurrentlyMatchedLocation)(state),
    previousLocation: server || !window._ReactPages_RouterHasFinishedInitialRender ? undefined : (0, _index.getPreviouslyMatchedLocation)(state)
  };
}
//# sourceMappingURL=getData.js.map