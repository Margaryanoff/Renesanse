"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
var _react = _interopRequireDefault(require("react"));
var _stringToStream = _interopRequireDefault(require("string-to-stream"));
var _multistream = _interopRequireDefault(require("multistream"));
var _html = require("./html.js");
var _normalize = _interopRequireDefault(require("../redux/normalize.js"));
var _timer = _interopRequireDefault(require("../timer.js"));
var _parseLocationUrl = _interopRequireDefault(require("../parseLocationUrl.js"));
var _getLocationUrl = _interopRequireDefault(require("../getLocationUrl.js"));
var _render = _interopRequireDefault(require("../redux/server/render.js"));
var _server = require("../redux/server/server.js");
var _mergeMeta = _interopRequireDefault(require("../meta/mergeMeta.js"));
var _getMetaTagsMarkup = _interopRequireDefault(require("../meta/getMetaTagsMarkup.js"));
var _convertOpenGraphLocaleToLanguageTag = _interopRequireDefault(require("../meta/convertOpenGraphLocaleToLanguageTag.js"));
var _reactRender = require("./reactRender.js");
var _excluded = ["cookies", "generateJavascript"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _default(_x, _x2) {
  return _ref2.apply(this, arguments);
}
function _ref2() {
  _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(settings, _ref) {
    var assets, proxy, url, origin, renderContent, _ref$html, html, cookies, locales, headers, getLoadContext, getInitialState, _settings, routes, rootComponent, codeSplit, location, path, serverSideRender, render, _yield$reduxInitializ, newCookies, generateJavascript, parameters, generateOuterHtmlBeforeContent, generateOuterHtmlAfterContent, _meta, _beforeContent, _afterContent, _yield$render, redirect, route, status, content, meta, rootComponentProps, time, beforeContent, streams, pageElement, afterContent;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          generateOuterHtmlAfterContent = function _generateOuterHtmlAft() {
            // `html` modifiers
            var bodyEnd = html.bodyEnd;

            // Normalize `html` parameters
            bodyEnd = typeof bodyEnd === 'function' ? bodyEnd(path, parameters) : bodyEnd;

            // Render all HTML that goes after React markup
            return (0, _html.renderAfterContent)({
              javascript: generateJavascript(),
              assets: assets,
              locales: locales,
              bodyEnd: bodyEnd,
              serverSideRender: serverSideRender,
              contentNotRendered: renderContent === false
            });
          };
          generateOuterHtmlBeforeContent = function _generateOuterHtmlBef(_ref3) {
            var meta = _ref3.meta;
            // `html` modifiers
            var head = html.head,
              bodyStart = html.bodyStart;

            // Normalize `html` parameters
            head = typeof head === 'function' ? head(path, parameters) : head;
            bodyStart = typeof bodyStart === 'function' ? bodyStart(path, parameters) : bodyStart;

            // Render all HTML that goes before React markup.
            return (0, _html.renderBeforeContent)({
              assets: assets,
              locale: meta.locale && (0, _convertOpenGraphLocaleToLanguageTag["default"])(meta.locale),
              meta: (0, _getMetaTagsMarkup["default"])(meta).join(''),
              head: head,
              bodyStart: bodyStart
            });
          };
          assets = _ref.assets, proxy = _ref.proxy, url = _ref.url, origin = _ref.origin, renderContent = _ref.renderContent, _ref$html = _ref.html, html = _ref$html === void 0 ? {} : _ref$html, cookies = _ref.cookies, locales = _ref.locales, headers = _ref.headers, getLoadContext = _ref.getLoadContext, getInitialState = _ref.getInitialState;
          settings = (0, _normalize["default"])(settings);
          _settings = settings, routes = _settings.routes, rootComponent = _settings.rootComponent, codeSplit = _settings.codeSplit; // `url` is obtained from Node.js `request.url` property,
          // which is always a relative URL.
          // https://nodejs.org/api/http.html#messageurl
          location = (0, _parseLocationUrl["default"])(url);
          path = location.pathname.replace(/\/$/, ''); // A special `base.html` page for static sites.
          // (e.g. the ones hosted on Amazon S3)
          serverSideRender = true;
          if (path === '/react-pages-base') {
            serverSideRender = false;
          }

          // If Redux is being used, then render for Redux.
          // Else render for pure React.
          render = _render["default"]; // `parameters` are used for `assets` and `html` modifiers.
          _context.next = 12;
          return (0, _server.initialize)(settings, {
            proxy: proxy,
            cookies: cookies,
            headers: headers,
            locales: locales,
            url: url,
            origin: origin,
            location: location,
            getLoadContext: getLoadContext,
            getInitialState: getInitialState
          });
        case 12:
          _yield$reduxInitializ = _context.sent;
          newCookies = _yield$reduxInitializ.cookies;
          generateJavascript = _yield$reduxInitializ.generateJavascript;
          parameters = _objectWithoutProperties(_yield$reduxInitializ, _excluded);
          // Normalize assets type and shape.
          assets = typeof assets === 'function' ? assets(path, parameters) : assets;
          if (assets.entries) {
            _context.next = 23;
            break;
          }
          if (!(assets.javascript && assets.javascript.main)) {
            _context.next = 22;
            break;
          }
          assets.entries = ['main'];
          _context.next = 23;
          break;
        case 22:
          throw new Error("\"assets.entries[]\" configuration parameter is required: it includes all Webpack \"entries\" for which javascripts and styles must be included on a server-rendered page. If you didn't set up any custom \"entries\" in Webpack configuration then the default Webpack entry is called \"main\". You don't seem to have the \"main\" entry so the server doesn't know which assets to include on the page (\"['main']\" is the default value for \"assets.entries\").");
        case 23:
          if (serverSideRender) {
            _context.next = 28;
            break;
          }
          // Get `<meta/>` tags for `/react-pages-base` route.
          _meta = (0, _mergeMeta["default"])({
            pageMeta: undefined,
            rootMeta: codeSplit ? routes[0].meta : routes[0].Component.meta,
            useSelector: function useSelector(getter) {
              return getter(parameters.store.getState());
            },
            stash: parameters.stash
          });
          _beforeContent = generateOuterHtmlBeforeContent({
            meta: _meta
          });
          _afterContent = generateOuterHtmlAfterContent();
          return _context.abrupt("return", {
            route: '/react-pages-base',
            status: 200,
            content: (0, _stringToStream["default"])(_beforeContent + _afterContent),
            cookies: []
          });
        case 28:
          _context.next = 30;
          return render(_objectSpread(_objectSpread({}, parameters), {}, {
            // routes,
            codeSplit: codeSplit
          }));
        case 30:
          _yield$render = _context.sent;
          redirect = _yield$render.redirect;
          route = _yield$render.route;
          status = _yield$render.status;
          content = _yield$render.content;
          meta = _yield$render.meta;
          rootComponentProps = _yield$render.rootComponentProps;
          time = _yield$render.time;
          if (!redirect) {
            _context.next = 40;
            break;
          }
          return _context.abrupt("return", {
            redirect: _objectSpread(_objectSpread({}, redirect), {}, {
              url: prependBasenameToUrl(redirect.url, settings.basename)
            })
          });
        case 40:
          beforeContent = generateOuterHtmlBeforeContent({
            meta: meta
          });
          streams = [(0, _stringToStream["default"])(beforeContent)];
          if (renderContent !== false) {
            // Render page content to a `Stream`
            // inserting this stream in the middle of `streams` array.
            // `array.splice(index, 0, element)` inserts `element` at `index`.
            pageElement = _react["default"].createElement(rootComponent, rootComponentProps, content);
            streams.push((0, _reactRender.createRenderingStream)(pageElement));
          }

          // Generating `afterContent` should wait for the React 18 rendering process
          // to finish: that's because there can be "Suspense" calls that might fetch data
          // and, therefore, modify Redux state.
          afterContent = generateOuterHtmlAfterContent();
          streams.push((0, _stringToStream["default"])(afterContent));
          return _context.abrupt("return", {
            route: route,
            status: status,
            content: new _multistream["default"](streams),
            time: time,
            cookies: newCookies
          });
        case 46:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _ref2.apply(this, arguments);
}
function prependBasenameToUrl(url, basename) {
  if (typeof url === 'string') {
    return (basename || '') + url;
  }
  return (0, _getLocationUrl["default"])(url, {
    basename: basename
  });
}
//# sourceMappingURL=render.js.map