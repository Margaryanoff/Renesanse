{"version":3,"file":"updateMeta.js","names":["browserDocument","BrowserDocument","updateMeta","meta","document","title","charset","normalizeMeta","metaTags","getMetaTags","getTitle","setTitle","updateMetaTag","newMetaTags","compact","map","key","value","forEach","removeMetaTag","addMetaTag","name","i","length","meta_tag","isMetaTag","getMetaTagValue","setMetaTagValue","splice"],"sources":["../../lib/meta/updateMeta.js"],"sourcesContent":["// import { compact } from 'lodash-es'\r\nimport compact from 'lodash/compact.js'\r\n\r\nimport BrowserDocument from './BrowserDocument.js'\r\nimport normalizeMeta from './normalizeMeta.js'\r\nimport expandArrays from './expandArrays.js'\r\nimport expandObjects from './expandObjects.js'\r\n\r\nimport escapeHtml from '../escapeHtml.js'\r\n\r\nconst browserDocument = new BrowserDocument()\r\n\r\n// Instead of the old `patchMeta()` (exported as `updateMeta()`) function,\r\n// developers could see if the new automatically-updated `.meta()`\r\n// with `useSelector` parameter works.\r\n/**\r\n * (advanced) (hacking around)\r\n * This client-side-only function is expored from this library\r\n * as an `updateMeta()` function. It could be used to \"patch\"\r\n * the latest applied `meta` for whatever reason.\r\n *\r\n * For example, one project required this type of function when\r\n * migrating `load()` methods from always being handled by this library\r\n * to being sometimes handled in a React's `useEffect()` hook\r\n * as a possible \"user experience\" enhancement.\r\n *\r\n * Another use case would be somehow changing the page's `title`\r\n * after some additional user-specific data has been loaded in a\r\n * React's `useEffect()` hook.\r\n *\r\n * Or, for example, when `<title/>` gets updated with the count of\r\n * unread notifications.\r\n */\r\n// export function patchMeta(metaProperties) {\r\n// \tupdateMeta({\r\n// \t\t...window._ReactPages_Page_Meta,\r\n// \t\t...metaProperties\r\n// \t})\r\n// }\r\n\r\n/**\r\n * Updates `<title/>` and `<meta/>` tags (inside `<head/>`).\r\n */\r\nexport default function updateMeta(meta, document = browserDocument) {\r\n\t// `patchMeta()` function is not exported in the new version of this library.\r\n\t// // Keep a reference to the latest applied `meta`\r\n\t// // in order for the `patchMeta()` public exported function to work.\r\n\t// // The public exported `patchMeta()` function is not the same as\r\n\t// // this `updateMeta()` function.\r\n\t// //\r\n\t// // Tests don't have a `window` global variable.\r\n\t// if (typeof window !== 'undefined') {\r\n\t// \twindow._ReactPages_Page_Meta = meta\r\n\t// }\r\n\r\n\tconst { title, charset } = meta\r\n\tmeta = normalizeMeta(meta)\r\n\r\n\t// Get all `<meta/>` tags.\r\n\t// (will be mutated)\r\n\tconst metaTags = document.getMetaTags()\r\n\r\n\t// Update `<title/>`.\r\n\tif (title && document.getTitle() !== title) {\r\n\t\tdocument.setTitle(title)\r\n\t}\r\n\r\n\t// Update `<meta charset/>`.\r\n\tif (charset) {\r\n\t\tupdateMetaTag(document, metaTags, 'charset', charset)\r\n\t}\r\n\r\n\t// Update existing `<meta/>` tags.\r\n\t// (removing them from `metaTags` array)\r\n\tconst newMetaTags = compact(\r\n\t\tmeta.map(([key, value]) => {\r\n\t\t\tif (!updateMetaTag(document, metaTags, key, value)) {\r\n\t\t\t\treturn [key, value]\r\n\t\t\t}\r\n\t\t})\r\n\t)\r\n\r\n\t// Delete no longer existent `<meta/>` tags.\r\n\tmetaTags.forEach(document.removeMetaTag)\r\n\r\n\t// Create new `<meta/>` tags.\r\n\tfor (const [key, value] of newMetaTags) {\r\n\t\tdocument.addMetaTag(key, value)\r\n\t}\r\n}\r\n\r\n/**\r\n * Updates `<meta/>` tag to a new `value` and removes it from `metaTags`.\r\n * @param {Document} document - `BrowserDocument` or `TestDocument`.\r\n * @return {boolean?}\r\n */\r\nfunction updateMetaTag(document, metaTags, name, value) {\r\n\tlet i = 0\r\n\twhile (i < metaTags.length) {\r\n\t\tconst meta_tag = metaTags[i]\r\n\t\tif (document.isMetaTag(meta_tag, name)) {\r\n\t\t\t// Update `<meta/>` tag `value`.\r\n\t\t\tif (document.getMetaTagValue(meta_tag) !== value) {\r\n\t\t\t\tdocument.setMetaTagValue(meta_tag, value)\r\n\t\t\t}\r\n\t\t\t// Remove it from `metaTags`.\r\n\t\t\tmetaTags.splice(i, 1)\r\n\t\t\t// Updated.\r\n\t\t\treturn true\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}"],"mappings":";;;;;;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEzC,IAAMA,eAAe,GAAG,IAAIC,2BAAe,EAAE;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACe,SAASC,UAAU,CAACC,IAAI,EAA8B;EAAA,IAA5BC,QAAQ,uEAAGJ,eAAe;EAClE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,YAA2BG,IAAI;IAAvBE,KAAK,SAALA,KAAK;IAAEC,OAAO,SAAPA,OAAO;EACtBH,IAAI,GAAG,IAAAI,yBAAa,EAACJ,IAAI,CAAC;;EAE1B;EACA;EACA,IAAMK,QAAQ,GAAGJ,QAAQ,CAACK,WAAW,EAAE;;EAEvC;EACA,IAAIJ,KAAK,IAAID,QAAQ,CAACM,QAAQ,EAAE,KAAKL,KAAK,EAAE;IAC3CD,QAAQ,CAACO,QAAQ,CAACN,KAAK,CAAC;EACzB;;EAEA;EACA,IAAIC,OAAO,EAAE;IACZM,aAAa,CAACR,QAAQ,EAAEI,QAAQ,EAAE,SAAS,EAAEF,OAAO,CAAC;EACtD;;EAEA;EACA;EACA,IAAMO,WAAW,GAAG,IAAAC,mBAAO,EAC1BX,IAAI,CAACY,GAAG,CAAC,gBAAkB;IAAA;MAAhBC,GAAG;MAAEC,KAAK;IACpB,IAAI,CAACL,aAAa,CAACR,QAAQ,EAAEI,QAAQ,EAAEQ,GAAG,EAAEC,KAAK,CAAC,EAAE;MACnD,OAAO,CAACD,GAAG,EAAEC,KAAK,CAAC;IACpB;EACD,CAAC,CAAC,CACF;;EAED;EACAT,QAAQ,CAACU,OAAO,CAACd,QAAQ,CAACe,aAAa,CAAC;;EAExC;EAAA,2CAC2BN,WAAW;IAAA;EAAA;IAAtC,oDAAwC;MAAA;QAA5BG,GAAG;QAAEC,KAAK;MACrBb,QAAQ,CAACgB,UAAU,CAACJ,GAAG,EAAEC,KAAK,CAAC;IAChC;EAAC;IAAA;EAAA;IAAA;EAAA;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASL,aAAa,CAACR,QAAQ,EAAEI,QAAQ,EAAEa,IAAI,EAAEJ,KAAK,EAAE;EACvD,IAAIK,CAAC,GAAG,CAAC;EACT,OAAOA,CAAC,GAAGd,QAAQ,CAACe,MAAM,EAAE;IAC3B,IAAMC,QAAQ,GAAGhB,QAAQ,CAACc,CAAC,CAAC;IAC5B,IAAIlB,QAAQ,CAACqB,SAAS,CAACD,QAAQ,EAAEH,IAAI,CAAC,EAAE;MACvC;MACA,IAAIjB,QAAQ,CAACsB,eAAe,CAACF,QAAQ,CAAC,KAAKP,KAAK,EAAE;QACjDb,QAAQ,CAACuB,eAAe,CAACH,QAAQ,EAAEP,KAAK,CAAC;MAC1C;MACA;MACAT,QAAQ,CAACoB,MAAM,CAACN,CAAC,EAAE,CAAC,CAAC;MACrB;MACA,OAAO,IAAI;IACZ;IACAA,CAAC,EAAE;EACJ;AACD"}